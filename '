use std::{cell::RefCell, collections::HashMap, path::PathBuf, rc::Rc, sync::Mutex};

use crate::{current_selected_view::ConfigurationState, prelude::*};
use eframe::{egui::RichText, epaint::Color32};
use once_cell::sync::Lazy;
use usermgmt_lib::config::{LoadedMgmtConfig, MgmtConfig};

pub fn draw(window: &mut UsermgmtWindow, ui: &mut egui::Ui) {
    let mut can_reload = true;
    // TODO: use "draw_utils::draw_status_msg()" instead
    match &window.conf_state.io_conf.status() {
        IoTaskStatus::NotStarted => {
            ui.label("No configuration loaded yet");
        }
        IoTaskStatus::Loading => {
            ui.label(RichText::new("Loading configuration").color(Color32::BLUE));
            can_reload = false;
        }
        IoTaskStatus::Successful(_) => {
            ui.label(RichText::new("Configuration loaded").color(Color32::GREEN));
        }
        IoTaskStatus::Failed(error) => {
            ui.label(
                RichText::new("Error in loadiding configuration.")
                    .strong()
                    .color(Color32::RED),
            );
            ui.label(RichText::new(format!("Error details. {}", error)).color(Color32::RED));
        }
    }

    draw_utils::draw_status_msg_w_label(
        ui,
        "Save Progress",
        window.conf_state.io_save_conf.status(),
        // TODO: Supply meaningful messages
        || String::from("a"),
        || String::from("a"),
        || String::from("a"),
        || String::from("a"),
    );

    draw_utils::draw_file_path(ui, window);
    draw_buttons(window, ui, can_reload);
    draw_fields(&mut window.conf_state, ui);
}

fn draw_buttons(window: &mut UsermgmtWindow, ui: &mut egui::Ui, can_reload: bool) {
    ui.horizontal(|ui| {
        if ui
            .add_enabled(can_reload, egui::Button::new("Reload"))
            .clicked()
        {
            let path = window.conf_path.clone();
            general_utils::start_load_config(&mut window.conf_state, Some(path));
        }
        if ui
            .add_enabled(can_reload, egui::Button::new("Save"))
            .clicked()
        {
            let path = window.conf_path.clone();
            save_config(&mut window.conf_state, path);
        }
    });
}

fn save_config(window: &mut ConfigurationState, conf_path: PathBuf) {
    if let IoTaskStatus::Successful(loaded) = window.io_conf.status() {
        let config = loaded.config.clone();
        window.io_save_conf.spawn_task(
            move || config.save(&conf_path),
            String::from("Saving configuration"),
        );
    }
}

fn draw_fields(window: &mut ConfigurationState, ui: &mut egui::Ui) {
    if let IoTaskStatus::Successful(LoadedMgmtConfig { config, .. }) = window.io_conf.status_mut() {
        egui::ScrollArea::vertical()
            .min_scrolled_height(400.0)
            .show(ui, |ui| {
                let map: Mutex<HashMap<&'static str, LabelTyp>> = Default::default();
                let fields = construct_fields(config, &map);
                for next in fields {
                    let mut draw_sep = true;
                    match next {
                        ConfiField::SingleOpt { val, label } => {
                            draw_utils::no_password_opt_enty_field(ui, &label, val);
                        }
                        ConfiField::Single { val, label } => {
                            draw_utils::no_password_enty_field(ui, &label, val, |_| {});
                        }
                        ConfiField::List { val, label } => {
                            draw_utils::list_view(ui, val, &label);
                            draw_sep = false;
                        }
                        ConfiField::Checkbox { val, label } => _ = ui.checkbox(val, &*label),
                        ConfiField::Number { val, label } => {
                            draw_utils::number_field(ui, &label, val)
                        }
                        ConfiField::NegNumber { val, label } => {
                            draw_utils::neg_number_field(ui, &label, val)
                        }
                    }

                    if draw_sep {
                        ui.separator();
                    }
                }
            });
    }
}

fn snake_to_label(input: &'static str, repos: &Mutex<HashMap<&'static str, Rc<str>>>) -> Rc<str> {
    let mut repos = repos.lock().unwrap();
    Rc::clone(repos.entry(input).or_insert_with(|| {
        Rc::from(
            input
                .split("_")
                .map(|word| {
                    let first = word.chars().next().unwrap().to_uppercase();
                    let list: String = first.chain(word.chars().skip(1)).collect();
                    list
                })
                .collect::<Vec<String>>()
                .join(" "),
        )
    }))
}
type CacheForConfFiels = Rc<RefCell<HashMap<&'static str, LabelTyp>>>;
fn construct_fields<'a>(config: &'a mut MgmtConfig, map: CacheForConfFiels) -> Vec<ConfiField<'a>> {
    macro_rules! create_conf_field {
        ($field:ident, $map:ident) => {
            (&mut config.$field, snake_to_label(stringify!($field), $map)).into()
        };
    }
    let mut fields: Vec<ConfiField> = vec![
        create_conf_field!(student_default_qos, map),
        // (&mut config.student_default_qos, "Student Default Qos").into(),
        create_conf_field!(staff_default_qos, map),
        create_conf_field!(default_ssh_user, map),
        // (&mut config.head_node, "Head/Slurm node address").into(),
        // (&mut config.nfs_host, "NFS Host").into(),
        // (&mut config.nfs_root_dir, "NFS Root Directory").into(),
        // (&mut config.valid_qos, "Valid Qos").into(),
        // (&mut config.student_qos, "Student Qos").into(),
        // (&mut config.staff_qos, "Staff Qos").into(),
        // (&mut config.valid_slurm_groups, "Valid slurm Groups").into(),
        // (&mut config.compute_nodes, "Computer nodes").into(),
        // (&mut config.ldap_domain_components, "LDAP Domain Components").into(),
        // (&mut config.ldap_org_unit, "LDAP Org Unit").into(),
        // (&mut config.ldap_bind_org_unit, "LDAP Binding Org Unit").into(),
        // (&mut config.ldap_bind_prefix, "LDAP Binding Prefix").into(),
        // (
        //     &mut config.ldap_readonly_user_prefix,
        //     "LDAP Readonly User Prefix",
        // )
        //     .into(),
        // (&mut config.ldap_readonly_bind, "LDAP Readonly Binding").into(),
        // (&mut config.ldap_server, "LDAP Server").into(),
        // (&mut config.ldap_readonly_user, "LDAP Readonly User").into(),
        // (&mut config.ldap_readonly_pw, "LDAP Readonly Password").into(),
        // (&mut config.include_ldap, "Include LDAP").into(),
        // (&mut config.include_slurm, "Incldue Slurm Readonly Password").into(),
        // (&mut config.include_dir_mgmt, "Include Directory Management").into(),
        // (&mut config.use_homedir_helper, "Use homedir Helper").into(),
        // (
        //     &mut config.run_slurm_remote,
        //     "Runs slurm commands on remote machines",
        // )
        //     .into(),
        // (&mut config.ssh_agent, "Use ssh agent").into(),
        // (&mut config.ssh_port, "Ssh port").into(),
        // (
        //     &mut config.compute_node_root_dir,
        //     "Computer Node Root Directory",
        // )
        //     .into(),
        // (&mut config.filesystem, "File System").into(),
        // (&mut config.home_filesystem, "Home Filesystem").into(),
        // (&mut config.nfs_filesystem, "NFS Filesystem").into(),
        // (&mut config.quota_softlimit, "Quota Softlimit").into(),
        // (&mut config.quota_hardlimit, "Quota Hardlimit").into(),
        // (&mut config.quota_nfs_softlimit, "Quota Nfs Softlimit").into(),
        // (&mut config.quota_nfs_hardlimit, "Quota Nfs Hardlimit").into(),
        // (&mut config.quota_home_softlimit, "Quota Home Softlimit").into(),
        // (&mut config.quota_home_hardlimit, "Quota Home Hardlimit").into(),
        // (&mut config.login_shell, "Login Shell").into(),
        // (&mut config.student_gid, "Sudent GID").into(),
        // (&mut config.staff_gid, "Staff GID").into(),
        // (&mut config.faculty_gid, "Faculty GID").into(),
        // (&mut config.sacctmgr_path, "Sacctmgr Path").into(),
    ];
    fields.sort();
    fields
}

type LabelTyp = Rc<str>;
#[derive(Debug)]
enum ConfiField<'a> {
    SingleOpt {
        val: &'a mut Option<String>,
        label: LabelTyp,
    },
    Single {
        val: &'a mut String,
        label: LabelTyp,
    },
    List {
        val: &'a mut Vec<String>,
        label: LabelTyp,
    },
    Checkbox {
        val: &'a mut bool,
        label: LabelTyp,
    },
    Number {
        val: &'a mut u32,
        label: LabelTyp,
    },
    NegNumber {
        val: &'a mut i32,
        label: LabelTyp,
    },
}

impl ConfiField<'_> {
    pub fn label(&self) -> &str {
        match self {
            ConfiField::SingleOpt { label, .. }
            | ConfiField::Single { label, .. }
            | ConfiField::List { label, .. }
            | ConfiField::Checkbox { label, .. }
            | ConfiField::Number { label, .. }
            | ConfiField::NegNumber { label, .. } => label,
        }
    }
}

impl PartialEq for ConfiField<'_> {
    fn eq(&self, other: &Self) -> bool {
        self.label() == other.label()
    }
}
impl Eq for ConfiField<'_> {}
impl Ord for ConfiField<'_> {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.label().cmp(other.label())
    }
}
impl PartialOrd for ConfiField<'_> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.label().cmp(other.label()))
    }
}

impl<'a> From<(&'a mut u32, LabelTyp)> for ConfiField<'a> {
    fn from((val, label): (&'a mut u32, LabelTyp)) -> Self {
        Self::Number { val, label }
    }
}
impl<'a> From<(&'a mut i32, LabelTyp)> for ConfiField<'a> {
    fn from((val, label): (&'a mut i32, LabelTyp)) -> Self {
        Self::NegNumber { val, label }
    }
}
impl<'a> From<(&'a mut bool, LabelTyp)> for ConfiField<'a> {
    fn from((val, label): (&'a mut bool, LabelTyp)) -> Self {
        Self::Checkbox { val, label }
    }
}
impl<'a> From<(&'a mut String, LabelTyp)> for ConfiField<'a> {
    fn from((val, label): (&'a mut String, LabelTyp)) -> Self {
        Self::Single { val, label }
    }
}
impl<'a> From<(&'a mut Option<String>, LabelTyp)> for ConfiField<'a> {
    fn from((val, label): (&'a mut Option<String>, LabelTyp)) -> Self {
        Self::SingleOpt { val, label }
    }
}
impl<'a> From<(&'a mut Vec<String>, LabelTyp)> for ConfiField<'a> {
    fn from((val, label): (&'a mut Vec<String>, LabelTyp)) -> Self {
        Self::List { val, label }
    }
}
